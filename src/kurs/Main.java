package kurs;

//Сегодня нас ждет несложная алгоритмическая задачка. Мы напишем функцию, которая на вход будет
//получать несортированный массив чисел первым параметром, и какой-то число вторым параметром.
//Функция должна вернуть TRUE в случае, если в массиве есть два числа, которые в сумме датю то,
//которое мы передали вторым параметром.
//        Например
//        array: [1, 3, 2, 12, 11]
//        N: 5
//        result: TRUE // так как 3 и 2 в сумме дают 5
//Мы должны сделать все то же самое, что описано в задаче №1. Но за линейное время.

public class Main {

    public static void main(String[] args) {
        System.out.println(hasTwoNumbers(new int[] {1, 3, 2, 12, 11}, 5));
    }

    private static boolean hasTwoNumbers(int[] a, int n) {
        //можно ли тут переделать все так, чтобы алгоритм был линейный
        //т.е. не цикл в цикле
        //вроде как советовали для таких целей использовать рекурсию
        //не представляю, нам нужно сравнить такие сочетания
        //1+3, 1+2, 1+12, 1+11
        //3+2, 3+12, 3+11
        //2+12, 2+11
        //если массив отсортировать, а потом двигаться с двух сторон
        //складывая самое маленькое и самое большое число
        //но пропуская, если сразу одно число больше
        //тогда нужно начать с сортировки быстрой
        //сам ее не писал, нашел на просторах инета
        quickSort(a, 0, a.length - 1);
        //а вот теперь попробуем, ну на нашем примере вернуло ИСТИНУ
        //а правильно ли в целом работает - непонятно, :)
        int l = 0;
        int r = a.length - 1;
        while (true) {
            if (l == r) break;
            if (a[r] > n) {
                r--;
                continue;
            }
            if (a[l] + a[r] == n) return true;
            l++;
        }
        return false;
    }

    private static void quickSort(int[] array, int low, int high) {
        //завершить выполнение, если длина массива равна 0
        if (array.length == 0) return;
        //завершить выполнение если уже нечего делить
        if (low >= high) return;
        // выбрать опорный элемент
        int middle = low + (high - low) / 2;
        int opora = array[middle];
        // разделить на подмассивы, который больше и меньше опорного элемента
        int i = low, j = high;
        while (i <= j) {
            while (array[i] < opora) {
                i++;
            }
            while (array[j] > opora) {
                j--;
            }
            //меняем местами
            if (i <= j) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }
        // вызов рекурсии для сортировки левой и правой части
        if (low < j) quickSort(array, low, j);
        if (high > i) quickSort(array, i, high);
    }

}
